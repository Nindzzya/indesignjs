#target InDesignif (app.documents.length > 0) {	var _dok = app.activeDocument;	var _rulerOrigin = _dok.viewPreferences.rulerOrigin;	_dok.viewPreferences.rulerOrigin = RulerOrigin.PAGE_ORIGIN;	var _zeroPoint = _dok.zeroPoint;	_dok.zeroPoint = [0,0];	if (app.scriptPreferences.version >= 6 ) { // Ab CS4 Undo bereitstellen		app.doScript(xmlImport, ScriptLanguage.JAVASCRIPT, _dok, UndoModes.ENTIRE_SCRIPT, "XML Import"); 			} 	else {		xmlImport(_dok);	}	_dok.viewPreferences.rulerOrigin =_rulerOrigin;			_dok.zeroPoint = _zeroPoint;} else {	alert ("Kein Dokument geöffnet!")}function xmlImport (_dok) {	_importMap = [];	// Block-Elemente	_importMap.push(["//rezept[@art='hauptgericht']/titel",		"titel-haupt", 		"block", "\r"]);	_importMap.push(["//rezept[@art='dessert']/titel",				"titel-dessert", 	"block", "\r"]);	_importMap.push(["//u-zwischen",										"u-zwischen", 	"block", "\r"]);	_importMap.push(["//schritt",												"schritt", 			"block", "\r"]);	_importMap.push(["//zutat/name",										"zutat", 			"block", "\r"]);	_importMap.push(["//bild-container",									"bild-container", "block", "\r"]);	// Inline-Elemente	_importMap.push(["//fett",			"fett", 		"inline", ""]);	_importMap.push(["//kursiv",		"kursiv", 	"inline", ""]);	_importMap.push(["//menge",	"fett", 		"inline", "\t"]);		//Load XML File 	var _xmlFile = File.openDialog ("Bitte wählen Sie die zu verarbeitende XML Datei aus", getFileFilter (".xml", "XML-Datei:"), false);	if (_xmlFile == null) {		alert ("Fehler bei Dateiauswahl!")		return;	}	// Block-Elemente die nur Inline-Elemente enthalten maskieren 	var _newXmlFile = saveWhiteSpace(_xmlFile, _importMap);		with (_dok.xmlImportPreferences)	{		importStyle = XMLImportStyles.MERGE_IMPORT;		createLinkToXML = false;				allowTransform = false;		repeatTextElements = false;		importTextIntoTables = false;		ignoreWhitespace = true;				removeUnmatchedExisting = false;		importCALSTables = false;	}			_dok.importXML(_newXmlFile);		_newXmlFile.remove();			// Maskierung entfernen	app.findGrepPreferences = NothingEnum.NOTHING;	app.changeGrepPreferences = NothingEnum.NOTHING;	app.findGrepPreferences.findWhat = "\\x{E000}";	app.changeGrepPreferences.changeTo = "";	_dok.xmlElements[0].changeGrep();		// Dokument formatieren 	var _root = _dok.xmlElements[0];	for (i = 0; i < _importMap.length; i++) {		var _map = _importMap[i];		var _xpath = _map[0];		var node = null; 		if (_map[2]== "block" ) _pStyle = getStyle(_map); 		if (_map[2]== "inline" ) _cStyle = getStyle(_map); 		// Die eigentliche XML-Rule		try { 			var _proc = app.xmlRuleProcessors.add([_xpath]); 			var _match = _proc.startProcessingRuleSet(_root); 			while( _match!=undefined ) {				_node = _match.element; 	 	 		if (_map[2]== "block" ) {										_node.insertTextAsContent (_map[3], XMLElementPosition.afterElement);					_node.applyParagraphStyle(_pStyle);				} 				if (_map[2]== "inline" ) {					_node.insertTextAsContent (_map[3], XMLElementPosition.afterElement);					_node.applyCharacterStyle (_cStyle);				} 				_match = _proc.findNextMatch(); 			}		}					catch(e) { 			throw (e); 		} finally { 			_proc.endProcessingRuleSet(); 			_proc.remove(); 		} 	} // end for 		// Bereinigung von Absätzen am Ende der Story	app.findGrepPreferences.findWhat = "\\r\\Z";	app.changeGrepPreferences.changeTo = "";	_dok.changeGrep();	app.findGrepPreferences = NothingEnum.NOTHING;	app.changeGrepPreferences = NothingEnum.NOTHING;}// Save Whitespace in Blocklevelfunction saveWhiteSpace(_xmlFile, _importMap) {	_xmlFile.encoding = "UTF8";	_xmlFile .open("r");	_text = _xmlFile .read();	_xmlFile.close();	for (var i = 0; i < _importMap.length; i++) {		var _tagName = _importMap[i][0].substring (_importMap[i][0].lastIndexOf ("/")+1);		var _re = RegExp ("(<\\/" + _tagName + ">)", "g");		_text =_text.replace (_re, "\uE000$1");	}		// Set Properties;	// Neue XML-Datei mit Properties schreiben ...	_newXmlFile = File (_xmlFile.path + "/idimport_" + _xmlFile.name)	_newXmlFile.open("w");	_newXmlFile.encoding = "UTF8";	// unicode signature, this is UTF16 but will convert to UTF8 "EF BB BF"	_xmlFile.write("\uFEFF");	_xmlFile.lineFeed = "unix";	_newXmlFile.write(_text);	_newXmlFile.close();		return _newXmlFile;}function getStyle (_map) {	if (_map[2]== "block" ) {		for (var i = 0; i < _dok.allParagraphStyles.length; i++) {			if (_dok.allParagraphStyles[i].name == _map[1]) {				return _dok.allParagraphStyles[i];			}		}		// Style muss erstellt werden 		return app.activeDocument.paragraphStyles.add({name:_map[1]});	} 	if (_map[2]== "inline" ) {		for (var i = 0; i < _dok.characterStyles.length; i++) {			if (_dok.characterStyles[i].name == _map[1] ) {				return _dok.characterStyles[i];			}		}		// Style muss erstellt werden 		return app.activeDocument.characterStyles.add({name:_map[1]});	}}// Filter für Dateiauswahl function getFileFilter (_ext, _string) {	if (File.fs == "Windows") {		var _filter = _string + "*"+ _ext;	} 	else {		function _filterFilesMac(file) {			while (file.alias) {				file = file.resolve();				if (file == null) { return false }			}			if (file.constructor.name == "Folder") return true;			var _extension = file.name.toLowerCase().slice(file.name.lastIndexOf("."));			if (_extension.indexOf (_ext) > -1 ) return true;			else return false		}		var _filter = _filterFilesMac;	} 	return _filter;}